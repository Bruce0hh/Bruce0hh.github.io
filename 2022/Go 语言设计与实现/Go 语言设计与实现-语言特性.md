[TOC]

# 语言特性

## 函数

### 函数调用

- Golang 使用栈传递参数和接收返回值，所以只需要在栈上多分配一些内存就可以返回多个返回值。

### 参数传递

> 传值：函数调用时会复制参数，被调用方和调用方持有不相关的两份数据。
>
> 传引用：函数调用时会传递参数的指针，被调用方和调用方持有相同的数据，任意一方做出的修改都会影响另一方。

Golang 选择了传值的方式，无论是传递基本类型、结构体还是指针，都会对传递的参数进行复制。

- 传递结构体时：会复制结构体中的全部内容。
- 传递结构体指针时：会复制结构体指针。
- 将指针作为参数传入某个函数时，函数内部会复制指针，也就是会同时出现两个指针指向原有的内存空间，因此 Golang 中传指针也是传值。

### 小结

1. 通过堆栈传递参数，入栈顺序是从右到左，参数计算的顺序是从左到右。
2. 函数返回值通过堆栈传递并由调用方预先分配内存空间。
3. 调用函数时都是传值，接收方会对入参进行复制再计算。

## 接口

### 隐式接口

- 在 Java 中，实现接口需要显式声明接口并实现所有方法；
- 在 Golang 中，实现接口的所有方法就隐式实现了接口。

### 类型

- `runtime.iface`结构体是带有一组方法的接口；
- `runtime.eface`结构体是不带任何方法的 `interface{}`类型。

### 指针与接口

|                      | 结构体实现接口 | 结构体指针实现接口 |
| -------------------- | -------------- | ------------------ |
| 结构体初始化变量     | ***通过***     | 不通过             |
| 结构体指针初始化变量 | 通过           | *通过*             |

- 当实现结构体的类型和初始化变量时返回的类型相同时，代码显然是能通过编译的。

```go
type Cat struct{}

type Duck interface {
	Quack()
}

//方法的接收是结构体，初始化变量是结构体指针 --通过
func (c Cat) Quack() {
    fmt.Println("meow")
}

func main() {
    var c Duck = &Cat{}
    c.Quack()
}
------------------------------------------
//方法的接收是结构体指针，初始化变量是结构体 --不通过
func (c *Cat) Quack() {
    fmt.Println("meow")
}

func main() {
    var c Duck = Cat{}
    c.Quack()
}

```

<img src="https://cdn.jsdelivr.net/gh/Bruce0hh/Bruce0hh.github.io/pic-bed/golang-interface-method-receiver.png" alt="golang-interface-method-receive"  />

- Golang 在传递参数的时候都是传值的。
- 对于`&Cat{}`来说，意味着复制一个新的`&Cat{}`指针，该指针与原来指针指向相同且唯一的结构体，所以编译器可以隐式地对变量解引用获取指针指向的结构体。
- 对于`Cat{}`来说，由于方法的参数是`*Cat`,编译器不会无中生有地创建一个指针，而当`Cat{}`被复制之后，这个指针的指向也不是原来的那个结构体而是被复制后的。

## 反射

**三大法则**：

1. `interface{}`变量可以转换成反射对象；
2. 从反射对象可以获取`interface{}`变量；
3. 要修改反射对象，其值必须可设置。