[TOC]

# 数据结构

## 数组

### 数组初始化

1. 显示指定数组大小：`arr1 := [3]int{1,2,3}`
2. 使用`[...]T`声明数组：`arr2 := [...]int{1,2,3}`

上述两种声明方式在运行期间得到的结果完全相同，后一种声明方式在编译期间就会转换成前一种，这也就是编译期对数组大小的推导。

对于由字面量组成的数组，根据数组元素数量的不同，编译器会做两种优化：

1. 当元素**少于或等于4个时**，会直接将数组中的元素放置在**栈**上；
2. 当元素**多于4个时**，会将数组中的元素放置到**静态区并在运行时取出**。

**总结：**在不考虑逃逸分析的情况下，如果数组元素少于或等于4个，那么所有变量会直接在栈上初始化；如果数组元素多于4个，变量就会在静态存储区初始化然后复制到栈上，这些转换后的代码才会继续进入中间代码生成和机器码生成两个阶段，最后生成可执行的二进制文件。

### 访问与赋值

- 数组和字符串一些简单的越界错误会在编译期发现，例如直接使用整数或者常量访问数组；但如果使用变量访问，编译器就无法提前发现。
- Golang 运行时发现数组、切片和字符串的越界操作时，会由运行时`runtime.panicIndex`和`runtime.goPanicIndex`触发程序的运行时错误并导致崩溃退出。
- Golang 为数组的访问操作生成了**判断数组上限**的指令`IsInBounds`以及当条件不满足时**触发程序崩溃**的`PanicBounds`指令。
- 编译器会将`PanicBounds`指令转换成上面的`panicIndex`函数，*当数组下标没有越界时*，编译器会**先获取数组的内存地址和访问的下标**，利用`PtrIndex`**计算出目标元素的地址**，最后使用 Load 操作将指针中的元素**加载到内存中**。

### 小结

Golang 对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在编译期间会转换成直接读写内存。在中间代码生成期间，编译器还会插入运行时方法`runtime.panicIndex`调用防止发生越界错误。无论是数组的寻址还是赋值，都是在编译阶段完成的，没有运行时的参与。

## 切片

很多操作功能都需要运行时（runtime）的支持。

### 数据结构

```go
type SliceHeader struct{
    Data uintptr //指向数组的指针
    Len	 int	//当前切片的长度
    Cap  int	//当前切片的容量，即Data数组的大小
}
```

### 初始化

1. **通过下标的方式获得数组或者切片的一部分**；`arr[0:3]` 或`slice[0:3]`
   - 使用下标初始化切片不会复制原数组或原切片中的数据，而只会创建一个指向原数组的切片结构体，所以**修改新切片的数据也会修改原切片**。
2. **使用字面量初始化新的切片**；`slice := []int{1,2,3}`
   - 如果使用字面量创建切片，大部分工作会在编译期间完成。使用 make 关键字创建切片时，很多工作需要运行时的参与。
3. **使用关键字 make 创建切片**。`slice := make([]int, 10)`
   1. 调用方必须向 make 函数传入切片大小以及可选容量；
   2. 类型检查期间，`typecheck` 函数会校验入参，检查 len 是否传入，保证传入的 cap 容量一定大于或等于 len；
   3. 中间代码生成的 `walkexpr` 函数会判断 **切片大小和容量是否足够小** 和 **切片是否发生了逃逸**，最终在堆中初始化（足够大或逃逸）；
   4. `makeslice` 函数计算切片占用的内存空间，并在堆中申请一块连续的内存： `内存空间 = 切片中元素大小 * 切片容量` ；
   5. `mallocgc` 函数用于申请内存。

### 访问元素 | 追加和扩容

使用 append 关键字向切片中追加元素也是常见的切片操作，中间代码生成阶段的 append 方法会根据返回值否是会覆盖原值进行判断：

- `append(slice, 1, 2, 3)`
- `slice = append(slice, 1, 2, 3)`

是否覆盖原变量的逻辑差不多，最大的区别在于得到的新切片是否会赋值回原变量。

#### 扩容

扩容策略：

- 如果期望容量大于当前容量的两倍，就会使用期望容量；
- 如果当前切片的长度小于1024，就会将容量翻倍；
- 如果当前切片的长度大于1024，就会每次增加25%的容量，直到新容量大于期望容量。

除了确定切片的大致容量，还需要**根据切片中的元素大小对齐内存**。当数组中元素所占字节大小为1、2、8的倍数是，运行时会将待申请的内存向上取整，取整时会使用`runtime.class_to_size`数组，使用该数组中的整数可以提高内存分配效率并减少碎片。

默认情况下，我们会将**目标容量和元素大小相乘得到占用的内存**。如果计算新容量时发生了内存溢出或者请求内存超过上限，程序就会直接崩溃退出。

如果切片中的元素不是指针类型，那么会调用`runtime.memclrNoHeapPointers`将超出切片当前长度的位置清空，并在最后使用`runtime.memmove`将原数组内存中的内容复制到新申请的内存中。

```go
var arr []int64
arr = append(arr, 1, 2, 3, 4, 5)

// 扩容期望的新容量为5，分配的内存大小为5*8(int64的字节大小)=40
// 向上取整内存到48字节，因此新切片的容量为48/8 = 6
```

### 复制

- 编译期间复制：`copy(a, b)`
- 运行时调用：`go copy(a, b)`

两种复制都会通过`runtime.memmove`将**整块内存的内容复制**到目标内存区域中，相比依次复制元素能够提供更好的性能。但在大切片上的操作会占用非常多的资源。

## 哈希表

### 数据结构

```go
type hamp struct {
    count	    int		//当前哈希表中的元素数量
    flags	    uint8	
    B		    uint8	//表示当前哈希表持有的 buckets 数量，但是因为哈希表中桶的数量都是2的倍数，所以该字段会存储对数，即len(buckets) == 2^B
    noverflow	uint16	//溢出桶数目
    hash0	    uint32	//哈希表的种子，它能作为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入
    
    buckets	    unsafe.Pointer
    oldbuckets	unsafe.Pointer	//哈希表在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半
    nevacuate	uintptr
    
    extra 		*mapextra
}

//每一个 runtime.bmap 都能存储8个键值对。
//当哈希表中存储的数据过多，单个桶已经装满时就会使用 extra.nextOverflow 中的桶存储溢出的数据。
type mapextra struct {
    overflow	 	*[]*bmap
    oldoverflow	 	*[]*bmap
    nextOverflow	*bmap
}

//随着哈希表存储的数据逐渐增多，会使用额外的桶存储溢出的数据，不会让单个桶中的数据超过8个。
type bmap struct {
    topbits  [8]uint8
    keys     [8]keytype
    values   [8]valuetype
    pad      uintptr
    overflow uintptr
}
```



### 初始化

1. **字面量**

   ```go
   hash := map[string]int {
       "1":2,
       "3":4,
       "5":6,
   }
   ```

   - 当哈希表中的元素**小于或等于25个**时，编译器会将所有键值对一次性加入哈希表中；
   - **超过25个**时，编译器就会创建两个数组分别存储键和值，这些键值对会通过 for 循环加入哈希表。
   - 使用字面量初始化的过程都会使用 Golang 的 make 关键字来创建新的哈希表，并通过最原始的 `[]`语法向哈希表追加元素。

2. **运行时**

   只要我们使用 make 创建哈希表，Golang 编译器都会在类型检查期间将它们转换成`runtime.makemap`。使用字面量初始化哈希表也只是 Golang 提供的辅助工具，最后调用的都是`runtime.makemap`。

**makemap 函数步骤**：

1. 计算哈希表占用的内存是否溢出或者超出能分配的最大值；
2. 调用`runtime.fastrand`获取一个随机的哈希种子；
3. 根据传入的`hint`计算出至少需要多少桶；
4. 使用`runtime.makeBucketArray`创建用于保存桶的数组。

**makeBucketArray 函数**

- 根据传入的 B 计算出需要创建的桶数，并在内存中分配一块连续的空间用于存储数据。
- 当通的数量少于24时，由于数据较少、使用溢出桶的可能性较小，因此会省略创建过程以减少额外开销。
- 当桶的数量多于24时，会额外创建 $2^{B-4}$ 个溢出桶。
- 正常情况下，正常桶和溢出桶在内存中的存储空间是连续的，当溢出桶数量较多时会通过`runtime.newobject`创建新的溢出桶。

### 读写操作

``` go
_ = hash[key]
```

1. **访问**

   ```go
   v := hash[k]		//使用 runtime.mapaccess1，该函数犯规一个指向目标值的指针
   v, ok := hash[k]	//使用 runtime.mapaccess2，还会多返回一个表示当前键对应的值是否存在的布尔值
   ```

   访问的过程中，哈希表会依次遍历正常桶和溢出桶中的数据，它会**先比较哈希的高8位**和桶中存储的 `tophash`，**后比较传入的值和桶中的值以加速数据的读写**。用于**选择桶序号的是哈希的最低几位**（从低位开始运算），用于**加速访问的是哈希的高8位**。这种设计能够降低同一个桶中有大量相等 `tophash` 的概率以免影响性能。

2. **写入**

   当形如 `hash[k]` 的表达式出现在赋值符号左侧时，该表达式也会在编译期间转换成 `runtime.mapassign`函数的调用。

   1. 首先函数会根据传入的键拿到对应的哈希和值；
   2. 然后通过遍历比较桶中存储的`tophash`和键的哈希，如果找到了相同的结果，就会返回目标位置的地址；
   3. 如果当前桶已满，哈希表会调用`runtime.hmap.newoverflow`创建新桶或者使用`runtime.hmap`预先在`noverflow`中创建好的桶来保存数据，新创建的桶不仅会被追加到已有桶的末尾，还会增加哈希表的 `noverflow` 计数器；
   4. 如果当前键值对**在哈希表中不存在**，哈希表会为新键值对规划存储的内存地址，通过`runtime.typedmemmove`移动到对应的内存空间中，并返回对应值的地址`val`。如果**在哈希表中存在**，就会直接返回目标区域的内存地址。

3. **扩容**（[【幼麟实验室】Golang合辑_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1hv411x7we?p=4)）

   `runtime.mapassign`函数会在以下两种情况下触发哈希表扩容：

   1. 负载因子超过6.5，`count / (2 ^ B) > 6.5`；（翻倍扩容）
   2. 哈希表使用了太多溢出桶，`noverflow > 2 ^ B`。（等量扩容 -> 意味着许多键值对被删除，空间被浪费）

   - 如果这次扩容是溢出桶太多导致的，那么这次扩容就是**等量扩容**`sameSizeGrow`。一旦哈希表中出现了过多的溢出桶，它就会创建新桶以保存数据，垃圾收集器清除老的溢出桶并释放内存。
   - 扩容过程中会通过`runtime.makeBucketArray`创建一组新桶和预创建的溢出桶，随后**将原有桶数组设置到`oldbuckets`上，并将新的空桶设置到`buckets`上**，溢出桶也使用了相同的逻辑更新。
   - 扩容后具体的数据分流，会在数据访问的时候逐渐迁移，类似Redis中的渐进式扩容。

4. **删除**

   哈希表的删除逻辑与写入逻辑很相似，只是触发哈希的删除需要使用关键字，如果在删除期间遇到了哈希表的扩容，就会分流桶中的元素，分流结束之后会找到桶中的目标元素完成键值对的删除工作。

### 小结

- Golang 使用拉链法解决哈希表中的哈希冲突。它的访问、写入和删除操作都在编译期间转换成了运行时的函数或方法。哈希表在每一个桶中存储键对应哈希的前8位，当对哈希表进行操作时，这些`tophash`就成为可以帮助哈希表快速遍历元素的缓存。

- 哈希表每个桶都只能存储8个键值对，一旦当前哈希表的某个键值对超出8个，新的键值对就会存储到哈希表的溢出桶中。随着键值对数量的增加，溢出桶的数量和哈希的装载因子也会逐渐升高，超过一定范围就会触发扩容，扩容会将桶的数量翻倍，元素再分配的过程也是在调用写操作时增量进行的，不会造成性能的瞬时巨大抖动。

## 字符串

字符串作为**只读**的数据类型，和 slice 结构较为相似，我们无法改变其本身的结构，但是在做拼接和类型转换等操作时一定要注意性能的损耗，遇到需要极致性能的场景一定要尽量减少类型转换的次数。