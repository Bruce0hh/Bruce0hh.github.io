[TOC]

# 代码之丑

> 参考：[代码之丑](https://time.geekbang.org/column/intro/100068401?tab=intro)
>
> 偶然看到本篇专栏，翻了一下这篇 [08 | 缺乏封装：如何应对火车代码和基本类型偏执问题？](https://time.geekbang.org/column/article/333135) 来读，还是比较能戳中我的。专栏使用Java语言，内容简洁易懂，比较基础，遂花了半天时间把专栏过了一遍，在此整理并记录笔记，也为之后阅读《重构》预热。

## 代码坏味道

我们也许都会认同代码整洁之道，认同代码需要正确性和可维护性，但是在实际工作中依然很难将代码写得更具维护性。

“代码坏味道”是[《重构》](https://book.douban.com/subject/30468597/)中提到的概念，很多人知道好代码是什么样子，却不知道坏代码是什么样子。这篇专栏就是将最常见的坏代码呈现在读者眼前，当你在实际编程中遇到它们的时候，能够警觉。

### 坏味道自查表

<table>
    <thead>
        <tr>
            <td rowspan="2">命名</td>
            <td><input type="checkbox" /> 命名是否具有业务含义 </td>
        </tr>
        <tr>
            <td><input type="checkbox" /> 命名是否符合英语语法 </td>
        </tr>
        <tr>
            <td rowspan="2">函数</td>
            <td><input type="checkbox" /> 代码是否超过（）行 </td>
        </tr>
        <tr>
            <td><input type="checkbox" /> 参数列表是否超过（）个 </td>
        </tr>
        <tr>
            <td rowspan="2">类</td>
            <td><input type="checkbox" /> 类的字段是否超过（）个 </td>
        </tr>
        <tr>
            <td><input type="checkbox" /> 类之间的依赖关系是否符合架构规则 </td>
        </tr>
        <tr>
            <td rowspan="8">语句</td>
            <td><input type="checkbox" /> 是否使用for循环 </td>
        </tr>
        <tr>
            <td><input type="checkbox" /> 是否使用else </td>
        </tr>
        <tr>
            <td><input type="checkbox" /> 是否有重复的switch </td>
        </tr>
        <tr>
            <td><input type="checkbox" /> 一行代码中是否出现了连续的方法调用 </td>
        </tr>
        <tr>
            <td><input type="checkbox" /> 代码中是否出现了Setter </td>
        </tr>
        <tr>
            <td><input type="checkbox" /> 变量声明之后是否有立即赋值 </td>
        </tr>
        <tr>
            <td><input type="checkbox" /> 集合声明之后是否有立即添加元素 </td>
        </tr>
        <tr>
            <td><input type="checkbox" /> 返回值是否可以使用Optional </td>
        </tr>
    </thead>
</table>

## 命名

> 好的命名，是体现业务含义的命名。

### 不精准命名

```java
    public void processChapter(long chapterId) {
        Chapter chapter = this.repository.findByChapterId(chapterId);
        if (chapter == null) {
            throw new IllegalArgumentException("Unknown chapter [" + chapterId + "]");
        }
        chapter.setTranslationState(TranslationState.TRANSLATING);
        this.repository.save(chapter);
    }
```

这段代码的逻辑就是把一个章节的翻译状态改成翻译中。这个函数名字叫做`processChapter`（处理章节），这个名字过于宽泛，没有错但不精准。

1. **命名过于宽泛，不能精准描述，这是很多代码在命名上存在的严重问题，也是代码难以理解的根源所在**。

2. **命名要能够描述出这段代码在做的事情**。

   `changeChapterToTranslating`这个名字更进一步，但是也不算个好名字，因为它更多是在描述细节。

3. **一个好的名字应该描述意图，而非细节**。

   代码逻辑在这里是开启了一个翻译的过程，这段函数应该命名为`startTranslation`。

### 技术命名

```java
	List<Book> bookList = service.getBooks();
```

这个`bookList`之所以叫`bookList`，因为它的声明的类型就是List。这种命名是一种基于实现细节的命名方式，会带来很多问题。

1. **编程有一个重要的原则是面向接口编程，就是不要面向实现编程，因为接口是稳定的，而实现是易变的**。
2. 事实上，在实际的代码中，技术名词的出现，**往往就意味着它缺少了一个应有的模型**。
3. 一个技术类的项目中，这些技术术语其实就是它的业务语言。但对于业务项目来说，这个说法就必须重新审视了。

### 用业务语言写代码

```java
    // before
	// 确认章节内容审核通过 chapterId是章节ID，userId是审核人ID
	public void approveChapter(long chapterId, long userId) {

        ...

    }
	// after
	public void approveChapter(long chapterId, long reviewerUserId) {

        ...

    }
```

这个userId并不是一个好的命名 ，它还需要更多的解释，更好的命名是`reviewerUserId`，因为这个用户在这个场景下扮演的角色是审核人（Reviewer）。

1. **编写可维护的代码要使用业务语言**。
2. 建立团队的词汇表。



## 乱用英语

> 编写符合英语语法规则的代码。最低限度的要求是写出来的代码要像是在用英语表达。

### 违反语法规则的命名

```java
　　// before
	public void completedTranslate(final List<ChapterId> chapterIds) {
　　  List<Chapter> chapters = repository.findByChapterIdIn(chapterIds);
　　  chapters.forEach(Chapter::completedTranslate);
　　  repository.saveAll(chapters);
    }
	// after
	public void completeTranslation(final List<ChapterId> chapterIds) {
　　  List<Chapter> chapters = repository.findByChapterIdIn(chapterIds);
　　  chapters.forEach(Chapter::completeTranslation);
　　  repository.saveAll(chapters);
　　 }
```

1. 类名是一个名词，表示一个对象，而方法名则是一个动词，或者是动宾短语，表示一个动作。

   `completedTranslate`并不是一个有效的动宾结构，只要把“完成”翻译为complete，“翻译”用它的名词形式translation就可以了。所以这个函数名可以改成`completeTranslation`。

2. 函数名应该是一个动词。

   比如，一个函数名是`retranslation`，意图是重新翻译。它的正确意命名应该是`retranslate`。

### 不准确的英语词汇/拼写错误

1. 在这种情况下，最好的解决方案还是建立起一个业务词汇表，千万不要臆想。**用集体智慧，而非个体智慧**。
2. 通过工具纠正错误。
3. 经常性进行代码评审。

## 重复代码

> 不要重复自己，不要复制粘贴。

### 重复的结构

```java
　　// before
   @Task
　　public void sendBook() {
　　  try {
　　    this.service.sendBook();
　　  } catch (Throwable t) {
　　    this.notification.send(new SendFailure(t)));
　　    throw t;
　　  }
　　}

　　@Task
　　public void sendChapter() {
　　  try {
　　    this.service.sendChapter();
　　  } catch (Throwable t) {
　　    this.notification.send(new SendFailure(t)));
　　    throw t;
　　  }
　　}

　　@Task
　　public void startTranslation() {
　　  try {
　　    this.service.startTranslation();
　　  } catch (Throwable t) {
　　    this.notification.send(new SendFailure(t)));
　　    throw t;
　　  }
　　}
```

我们可以看到，虽然三个函数调用的业务代码不同，但它们的结构是一致的。我们就可以把这个结构提取出来，就是提出一个接口。

```java
　　// after
   private void executeTask(final Runnable runnable) {
　　  try {
　　    runnable.run();
　　  } catch (Throwable t) {
　　    this.notification.send(new SendFailure(t)));
　　    throw t;
　　  }
　　}

　　@Task
　　public void sendBook() {
　　  executeTask(this.service::sendBook);
　　}

　　@Task
　　public void sendChapter() {
　　  executeTask(this.service::sendChapter);
　　}

　　@Task
　　public void startTranslation() {
　　  executeTask(this.service::startTranslation);
　　}
```

动词不同时，并不代表没有重复代码产生。

### 做真正的选择

```java
　　// before
   if (user.isEditor()) {
　　  service.editChapter(chapterId, title, content, true);
　　} else {
　　  service.editChapter(chapterId, title, content, false);
　　}
   // after
   boolean approved = isApproved(user);

　　service.editChapter(chapterId, title, content, approved);
　　private boolean isApproved(final User user) {
　　  return user.isEditor();
　　}
```

1. **只要你看到 if 语句出现，而且 if 和 else 的代码块长得又比较像，多半就是出现了这个坏味道**。
2. **写代码要想做到 DRY(Don't Repeat Yourself)，一个关键点是能够发现重复**。
3. 千万不要复制粘贴，**如果需要复制粘贴，首先应该做的是提取一个新的函数出来，把公共的部分先统一掉。**

> Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.
>
> 在一个系统中，每一处知识都必须有单一、明确、权威地表述。

## 长函数

> 把函数写短，越短越好。

**对于长函数的容忍度高，这是导致长函数产生的关键点**。（作者给出的标准是Java语言中至多20行一个函数）

### 长函数的产生

1. 以性能为由。
2. 平铺直叙写代码。
3. 一次增加一点点代码。

### 消灭长函数的原则

1. 定义好函数长度的标准。
2. 做好“分离关注点”。
3. **性能优化不应该是写代码的第一考量**。
4. 提取函数。

