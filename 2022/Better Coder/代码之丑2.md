[TOC]

# 代码之丑

## 滥用控制语句

> 循环和选择语句，可能都是坏味道。

```java
// before
public void distributeEpubs(final long bookId) {
    List<Epub> epubs = this.getEpubsByBookId(bookId);
    for (Epub epub : epubs) {
        if (epub.isValid()) {
            boolean registered = this.registerIsbn(epub);
            if (registered) {
                this.sendEpub(epub);
            }
        }
    }
}
```

这是一段做EPUB分发的代码，EPUB是一种电子格式。在这里，我们根据作品ID找到要分发的EPUB，然后检查EPUB的有效性。对于有效的EPUB，我们要为它注册ISBN信息，注册成功之后，将这个EPUB发送出去。

这段代码的作者只是按需求一步步地把代码实现出来（**平铺直叙地写代码**）。从实现代码的功能角度来说，这段代码肯定没错，但问题在于，在把功能实现之后，他停了下来，而没有把代码重新整理一下。

```java
// after 第一次
public void distributeEpubs(final long bookId) {
    List<Epub> epubs = this.getEpubsByBookId(bookId);
    for (Epub epub : epubs) {
        this.distributeEpub(epub);
    }
}

public void distributeEpub(final Epub epub) {
    if (epub.isValid()) {
        boolean registered = this.registerIsbn(epub);
        if (reigsterd) {
            this.sendEpub(epub);
        }
    }
}
```

### if 和 else

我们可以使用卫语句（guard clause）来解决 if 语句的多重嵌套问题，就是设置单独的检查条件，不满足这个检查条件时，立刻从函数中返回。

这是一种典型的重构手法：**以卫语句取代嵌套的条件表达式（Replace Nested Conditional with Guard Clauses）**。

```java
// after 第二次
private void distributeEpub(final Epub epub) {
    if (!epub.isValid()) {
        return;
    }
    boolean registered = this.registerIsbn(epub);
    if (!registered) {
        return;
    }
    this.sendEpub(epub);
}
```

当代码里只有一层缩进时，代码的复杂度就大大降低了，理解成本和出现问题之后定位的成本也随之大幅度降低。

**函数至多有一层缩进**。还有一个规则是：**不要使用 else 关键字**。

```java
// before
public double getEpubPrice(final boolean highQuality, final int chapterSequence) {
    double price = 0;
    if (highQuality && chapterSequence > START_CHARGING_SEQUENCE) {
        price = 4.99;
    } else if (sequenceNumber > START_CHARGING_SEQUENCE
          && sequenceNumber <= FURTHER_CHARGING_SEQUENCE) {
        price = 1.99;
    } else if (sequenceNumber > FURTHER_CHARGING_SEQUENCE) {
        price = 2.99;
    } else {
        price = 0.99;
    }
    return price;
}
```

这是一个根据EPUB信息进行定价的函数，它的定价逻辑正如代码中所示。就这段代码而言，如果想不使用 else，一个简单的处理手法就是让每个逻辑提前返回，这和我们前面提到的卫语句的解决方案如出一辙。

```java
// after
public double getEpubPrice(fianl boolean highQuality, final int chapterSequence) {
    if (highQuality && chapterSequence > START_CHARGING_SEQUENCE) {
        return 4.99;
    }

    if (sequenceNumber > START_CHARGING_SEQUENCE
        && sequenceNumber <= FURTHER_CHARGING_SEQUENCE) {
        return 1.99;
    }

    if (sequenceNumber > FURTHER_CHARGING_SEQUENCE) {
        return 2.99;
    }
    return 0.99;
}
```

对于这种逻辑上还比较简单的代码，这么改造还是比较容易的，而对于一些更为复杂的代码，也许就要用到多态来改进代码了。不过在实际项目中，大部分代码逻辑都是主键变得复杂的，所以，最好还在它比较简单时，就把坏味道消灭掉。这才是理想的做法。

无论是嵌套的代码，还是 else 语句，我们之所以要把它们视为坏味道，本质上都是在追求简单，因为一段代码的分支过多，其复杂度就会大幅度增加。

在软件开发中，有一个衡量代码复杂度常用的标准，叫做圈复杂度（Cyclomatic complexity，CC），圈复杂度越高，代码越复杂，理解和维护的成本就越高。在圈复杂度的判定中，循环和选择语句占有重要的地位。只要我们能够消除嵌套，消除 else，代码的圈复杂度就不会很高，理解和维护的成本自然也就会随之降低。

### 重复的 Switch

```java
// before
public double getBookPrice(final User user, final Book book) {

    double price = book.getPrice();

    switch (user.getLevel()) {
        case UserLevel.SILVER:
            return price * 0.9;
        case UserLevel.GOLD:
            return price * 0.8;
        case UserLevel.PLATINUM:
            return price * 0.75;
        default:
            return price;
    }
}

public double getEpubPrice(final User user, final Epub epub) {

    double price = epub.getPrice();

    switch (user.getLevel()) {
        case UserLevel.SILVER:
            return price * 0.95;
        case UserLevel.GOLD:
            return price * 0.85;
        case UserLevel.PLATINUM:
            return price * 0.8;
        default:
            return price;
    }
}
```

以上代码的 switch 部分都是根据用户级别进行判断。之所以会出现重复的 switch，通常都是缺少了一个模型。所以，应对这种坏味道，重构的手法是：**以多态取代条件表达式（Replace Conditional with Ploymorphism）**。

```java
// after
public double getBookPrice(final User user, final Book book) {
    UserLevel level = user.getUserLevel()
        return level.getBookPrice(book);
}

public double getEpubPrice(final User user, final Epub epub) {
    UserLevel level = user.getUserLevel()
        return level.getEpubPrice(epub);
}

// 多态
interface UserLevel {

    double getBookPrice(Book book);

    double getEpubPrice(Epub epub);

}

class RegularUserLevel implements UserLevel {

    public double getBookPrice(final Book book) {
        return book.getPrice();
    }

    public double getEpubPrice(final Epub epub) {
        return epub.getPrice();
    }
}

class GoldUserLevel implements UserLevel {

    public double getBookPrice(final Book book) {
        return book.getPrice() * 0.8;
    }

    public double getEpubPrice(final Epub epub) {
        return epub.getPrice() * 0.85;
    }

}

class SilverUserLevel implements UserLevel {

    public double getBookPrice(final Book book) {
        return book.getPrice() * 0.9;
    }

    public double getEpubPrice(final Epub epub) {
        return epub.getPrice() * 0.85;
    }
}

class PlatinumUserLevel implements UserLevel {

    public double getBookPrice(final Book book) {
        return book.getPrice() * 0.75;
    }

    public double getEpubPrice(final Epub epub) {
        return epub.getPrice() * 0.8;
    }
}
```

这个重构的手法，以多态取代的是条件表达式，而不仅仅是取代 switch，也包括 if else 的写法。



## 缺乏封装

> 构建模型，封装散落的代码。

### 火车残骸（Train Wreck）

```java
String name = book.getAuthor().getName();
```

这段代码表达的是“获得一部作品作者的名字”。这就是说，我们必须得知道，作者的姓名是存储在作品的作者字段里的。

这时你就要注意了：当你必须得了解一个类的细节，才能写出代码时，这只能说明一件事，这个封装是失败的。

Martin Fowler 在《[重构](https://book.douban.com/subject/33400354/)》中给这种坏味道起的名字叫**过长的消息链（Message Chains）**，而有人则给它起了一个更为夸张的名字：火车残骸，形容这样的代码就像火车残骸一般，断得一节一节的。

解决这种代码的重构手法叫做**隐藏委托关系（Hide Delegate）**。

```java
class Book {
    ...
    public String getAuthorName() {
        return this.author.getName();
    }
    ...
}

String name = book.getAuthorName();
```

