[TOC]

# System Design Interview(3)

## Rate Limiter（限流器）

> 网络系统中，限流器可用来控制客户端或服务端发送流量的速度。在HTTP的世界里，限流器可以用来限制客户端在指定时间段发送请求的数量。如果API请求数量超过限流器所定义的门槛值，所有额外的调用都会被挡下来。

## 限流器优点

- 避免 DoS（Denial of Service：拒绝服务）攻击造成资源不足的问题。
- 降低成本。针对过多的请求做出限制，也可以降低服务器的负担，而且可以让更多资源分配给具有高优先级的API。
- 防止服务器出现超载的问题。如果要降低服务器的负担，可使用一个限流器来筛选掉机器人，或是阻挡用户不当行为所引起的过多请求。

## 系统设计

### 第一步：了解问题并确立设计的范围

系统需求

- 准确限制过多的请求。
- 低延迟。限流器不应减慢HTTP的反应时间。
- 尽可能少用一些内存。
- 采用分布式限流器的做法。多个服务器或者多个进程，可共用一个限流器。
- 异常处理能力。当用户请求收到限制时，要向用户显示明确的异常通知。
- 高容错。如果限流器出现任何问题（比如缓存服务器离线），也不能影响整个系统。

###  第二步：提出高阶设计

- 评估你目前现有的技术，例如擅长的编程语言、现有的缓存服务等。
- 确认符合你业务需求的限流器算法。如果你是在服务器上配置限流器的功能，就可以完全控制所用的算法。如果你用的是第三方服务，选择上就有可能会受到一些限制。
- 如果你已经采用微服务架构，而且在你的设计中也有用到API网关来执行身份验证、IP白名单等功能，那么你就在API网关上添加限流器的功能。
- 打造自己的限流器服务，需要花费一些时间。如果你并没有足够的工程资源配置限流器，也许采用第三方服务是一个更好的选择。

### 限流器算法

- Token 桶（Token bucket）
  - 优点：简单易实现，并且允许短时间的流量并发。
  - 缺点：在应对流量并发的时候，正确调整桶的大小和填充率会比较有挑战性。
- 漏桶（Leaking bucket）
  - 优点：使用队列易实现。相比 token bucket 更注重流量整形，速率曲线更平滑。
  - 缺点：面对突发流量，消费速率固定，存在效率问题。
- 固定窗口计数器（Fixed window counter）
  - 优点：简单易理解。
  - 缺点：遇到突发流量，可能会导致通过的请求数超过阈值。
- 滑动窗口日志（Sliding window log）
  - 优点：算法实现的限速非常准确。
  - 缺点：它会消耗更多的内存。
- 滑动窗口计数器（Sliding window counter）
  - 优点：比较易于处理流量高峰的问题。
  - 缺点：计算量较大，消耗很多的内存。

### 高阶架构

使用 Redis 作为缓存，将数据保存到 Redis。使用 Redis 中的 INCR 和 EXPIRE 特性。

- 客户端向限流器发起请求。
- 限流器从 Redis 中对应的 KEY 中获取值，检查是否超限。
  - 超出限制，则拒绝请求。
  - 未超出限制，限流器将请求发送到 API 服务器。INCR 将值加一，存回 Redis。
- 设置计数器的过期时间，过期即使用 EXPIRE 自动删除。

### 第三步：深入设计

详细设计

- 限速规则存储在硬盘里，Worker 程序会定期取出规则，将规则存入缓存。
- 客户端向服务器发送请求的时候，先会发送到限流器。
- 限流器会从缓存中读取规则，然后从 Redis 中获取计数器的值，以及前一次的时间戳。
  - 请求未被限流，会被转送到 API 服务器中。
  - 请求限流，限流器将 429 过多请求的错误发给客户端。此时，该请求会被丢弃或转入到消息队列。

### 分布式限流器

冲突问题：参考资料：[Lua 脚本 + Redis ZSORT](https://engineering.classdojo.com/blog/2015/02/06/rolling-rate-limiter/)

同步问题：将多个限流器的数据放到统一的 Redis 系统中。

