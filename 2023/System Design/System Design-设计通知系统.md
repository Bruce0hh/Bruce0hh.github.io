[TOC]

# System Design Interview(4)

## 设计通知系统

> 服务1~服务N --> 通知系统 --> 第三方服务 --> 客户端

### 高阶设计

- **服务**：这里的服务可能是微服务、cron job，或是可能触发通知发送事件的分布式系统。比如付款信息通知、快递物流信息。
- **通知系统**：通知系统时整个发送/接收通知的中心。我们先从简单的做法开始，只使用一个通知服务器。它可以提供API给服务1~服务N，并针对第三方服务打造通知所需的负载内容（payload）。
- **第三方服务**：第三方服务负责向使用者传递通知。与第三方服务整合时，我们必须特别注意可扩展性。可扩展性的意思就是一个可轻松插拔第三方服务的灵活系统。

### 问题

- **单点故障（SPOF）**：只使用一个单独的服务器，就表明会有单点故障。
- **难以扩展**：这个通知系统使用单一服务器，负责处理与推送通知相关的所有内容。如果想要独立扩展数据库、缓存或采取其他不同的通知处理方式，都会是一项具有挑战性的任务。
- **性能瓶颈**：通知的处理和发送，可能会占用大量的资源。在单一系统中处理所有内容，可能会导致系统超载的问题。

### 高阶设计（改进版）

- 把数据库与缓存移出通知系统服务器。
- 添加更多的通知服务器，并建立自动水平扩展的能力。
- 导入消息队列，让系统的各个元素得以解耦。

> 服务1~服务N --> 通知服务器 --> 缓存 --> 数据库 --> 消息队列 --> worker --> 第三方服务 --> 客户端

- **服务**：根据不同的服务，通过服务器所提供的API，发送出不同的通知。
- **通知服务器**：
  - 提供API给各种不同的服务，以发送通知。我们只能通过已验证的客户端来存取这些API，以避免制造许多垃圾消息。这里多半是通过验证码（比如手机号、email）的方式，来进行基本的验证。
  - 查询缓存或数据库，以取得通知所需的数据。
  - 把通知数据放入不同的消息队列，以进行平行处理。
- **缓存**：用户信息、设备信息、通知模板等，都放入缓存。
- **数据库**：负责存储用户、通知、设置等相关数据。
- **消息队列**：可移除各个元素之间的依赖关系。如果发送了大量的通知，消息队列也可以充当缓冲区。每一种通知类型都会被指定到不同的消息队列，这样一来，如果有某个第三方服务出问题，也不会影响到其他类型的通知。
- **worker**：指一堆服务器，可以从消息队列中提取出通知事件，然后再发送到相应的第三方服务。

### 流程

1. 某个服务调用通知服务器所提供的API来发送通知。
2. 通知服务器从缓存或者数据库中取得 metadata（例如用户信息、设备token和通知设定）。
3. 通知事件被发送到相应的消息队列中进行处理。
4. woker 从消息队列中取出通知事件。
5. woker 把通知发送给第三方服务。
6. 第三方服务把通知发送到用户的客户端。

### 深入设计

**可靠性**

- **如何防止数据丢失？**

  通知系统最重要的要求之一，就是不能丢失数据。通知通常可以接受延迟或重新排队，但绝不能接受丢失的情况。为了满足要求，通知系统会把通知数据保存在数据库，并实现重试的机制。为了保持数据的持久性，因此会采用一个通知日志记录数据库。

- **接收者只会收到一次通知吗？**

  不是，虽然通知在大多数情况下只会发送一次，不过由于分布式系统的特性，有可能会导致重复通知的情况。为了减少重复的情况，我们引入了重复数据删除机制，并仔细处理每一次通知失败的状况。

**通知模版**

大型通知系统每天都会发送好几百万则通知，而且其中许多通知的格式都很类似。只要采用通知模板的做法，就不需要每次都重新开始建立每一则通知。使用通知模板的好处就是，可以保持一致的格式、减少不经意的错误，而且可以节省时间。

**通知设定**

可以在客户端或服务端配置用户是否接收消息。

**限速**

为了避免过多的通知，可以限制用户可接收通知数量。

**重试机制**

如果第三方服务无法发送通知，就会把消息添加到消息队列里进行重试。但如果问题一直存在，就需要向开发者发出告警。

**队列监视**/**事件追踪**

需要对消息队列进行监视，及时可能发生的处理消息延迟问题。另外最好可以对消息事件进行追踪，比如订阅、取消、发送、点击等。

### 深入设计总结

- 给服务器新增更重要的功能：身份验证和限速机制。
- 添加重试机制，以处理通知失败的情况。系统如果无法发送通知，就会将通知放到相应的消息队列，然后根据预定值和次数进行重试。
- 通知模板可提供具有一致性和高效的通知生成功能。
- 提供监视与追踪功能，为系统运行状况检查与未来改进做参考。