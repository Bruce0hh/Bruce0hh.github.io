[TOC]

# System Design Interview(5)

## 系统设计

- **发布个人动态**：用户发布推文，会把相应的数据写入缓存和数据库，推文也会被发送到好友的动态信息中。
- **构建动态消息**：我们暂且假设动态消息是按照时间倒序的方式，汇总好友的推文所构建出来的。

### API 设计

#### 发布个人动态 API 

*POST /v1/me/feed* 

参数：

- content：推文文字内容。
- auth_token：API 请求的身份认证。

#### 动态搜索 API

*GET /v1/me/feed*

参数：

- auth_token：API 请求的身份证认证。

## 高阶设计

### 发布动态

- **用户**：用户可以使用浏览器或者移动端设备查看或发布动态。
- **负载均衡器**：把流量分散到各个 Web 服务器。
- **Web 服务器**：Web 服务器会把流量重定向到不同的内部服务。
- **Post 服务**：把推文保存到数据库和缓存中。
- **Fanout 服务**：把新内容推送到好友的动态列表。动态列表的数据会被存储在缓存中，以便快速检索。
- **Notification 服务**：通知好友有新的内容，并发送推送通知。

### 建立动态讯息

- **用户**：使用者可以发出请求，以检索他自己的动态。
- **负载均衡器**：负载均衡器会把流量重定向到动态讯息服务。
- **Web 服务器**：Web 服务器会把请求转送到动态讯息服务。
- **动态讯息服务**：从缓存中获取动态讯息。
- **动态讯息缓存**：存储动态讯息ID，展示动态讯息时就会用到。

## 深入设计

### Fanout 服务

#### 写扩散-push

动态讯息会在写入期间就预先进行处理。新推文发布之后，就会立即传送到好友的缓存中。

**优点**：

- 动态讯息是即时生成的，可以立即推送给好友。
- 很快就能获取到动态讯息，因为在写入时已经处理好了。

**缺点**：

- 如果用户有很多好友，那么在获取好友列表并创建响应的动态讯息就会很慢很耗时。这就是所谓的 hotkey 问题。
- 对于一些不活跃或很少登录的用户来说，预先处理其动态讯息的做法实在很浪费计算资源。

**读扩散-pull**

动态讯息会在读取时段内生成。这是一种有需求才做动作的 on-demand 模型。当使用者载入其主页时，最新的推文就会被 pull 过去。

**优点**：

- 对于不活跃或很少登录的用户来说，读取时 fanout 是比较好的做法，因为这样比较不会浪费计算资源。
- 数据并不会推送给朋友，因此没有 hotkey 问题。

**缺点**：

- 由于动态讯息并未预先处理，因此在取得动态讯息时会比较慢。

通常我们会采用一种推拉结合做法，以取得两种做法的优点，同时避免掉它们各自的缺点。由于 Feed 的实时性非常重要，因此我们针对大多数用户采用了 push 模型。至于那些拥有很多好友/粉丝的明星或用户，我们会使用 pull 

模型拉取动态讯息，以避免系统超出负荷。

**Fanout 流程**

1. 从 graph 图数据库中取得朋友们的 ID。
2. 从用户缓存中取得好友们的信息。然后，系统会根据用户设定筛选出其中一些好友。
3. 把好友列表与新的推文 ID 发送到消息队列。

