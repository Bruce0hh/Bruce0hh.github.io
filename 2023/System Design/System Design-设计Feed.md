[TOC]

# System Design Interview(5)

## 系统设计

- **发布个人动态**：用户发布推文，会把相应的数据写入缓存和数据库，推文也会被发送到好友的动态信息中。
- **构建动态消息**：我们暂且假设动态消息是按照时间倒序的方式，汇总好友的推文所构建出来的。

### API 设计

#### 发布个人动态 API 

*POST /v1/me/feed* 

参数：

- content：推文文字内容。
- auth_token：API 请求的身份认证。

#### 动态搜索 API

*GET /v1/me/feed*

参数：

- auth_token：API 请求的身份证认证。

## 高阶设计

### 发布动态

- **用户**：用户可以使用浏览器或者移动端设备查看或发布动态。
- **负载均衡器**：把流量分散到各个 Web 服务器。
- **Web 服务器**：Web 服务器会把流量重定向到不同的内部服务。
- **Post 服务**：把推文保存到数据库和缓存中。
- **Fanout 服务**：把新内容推送到好友的动态列表。动态列表的数据会被存储在缓存中，以便快速检索。
- **Notification 服务**：通知好友有新的内容，并发送推送通知。

### 建立动态消息

- **用户**：使用者可以发出请求，以检索他自己的动态。
- **负载均衡器**：负载均衡器会把流量重定向到动态消息服务。
- **Web 服务器**：Web 服务器会把请求转送到动态消息服务。
- **动态消息服务**：从缓存中获取动态消息。
- **动态消息缓存**：存储动态消息ID，展示动态消息时就会用到。

## 深入设计

### Fanout 服务

#### 写扩散-push

动态消息会在写入期间就预先进行处理。新推文发布之后，就会立即传送到好友的缓存中。

**优点**：

- 动态消息是即时生成的，可以立即推送给好友。
- 很快就能获取到动态消息，因为在写入时已经处理好了。

**缺点**：

- 如果用户有很多好友，那么在获取好友列表并创建响应的动态消息就会很慢很耗时。这就是所谓的 hotkey 问题。
- 对于一些不活跃或很少登录的用户来说，预先处理其动态消息的做法实在很浪费计算资源。

**读扩散-pull**

动态消息会在读取时段内生成。这是一种有需求才做动作的 on-demand 模型。当使用者载入其主页时，最新的推文就会被 pull 过去。

**优点**：

- 对于不活跃或很少登录的用户来说，读取时 fanout 是比较好的做法，因为这样比较不会浪费计算资源。
- 数据并不会推送给朋友，因此没有 hotkey 问题。

**缺点**：

- 由于动态消息并未预先处理，因此在取得动态消息时会比较慢。

通常我们会采用一种推拉结合做法，以取得两种做法的优点，同时避免掉它们各自的缺点。由于 Feed 的实时性非常重要，因此我们针对大多数用户采用了 push 模型。至于那些拥有很多好友/粉丝的明星或用户，我们会使用 pull 

模型拉取动态消息，以避免系统超出负荷。

**Fanout 流程**

1. 从 graph 图数据库中取得朋友们的 ID。
2. 从用户缓存中取得好友们的信息。然后，系统会根据用户设定筛选出其中一些好友。
3. 把好友列表与新的推文 ID 发送到消息队列。
4. Fanout 会从消息队列中取得数据，并把动态消息数据存储到动态消息缓存中。
5. 将 *<post_id,  user_id>* 存储到动态消息缓存中。

### 动态消息检索

客户端流程：

1. 用户发送请求以检索其动态消息。比如 */v1/me/feed* 。
2. 负载均衡器会把请求重新分配到 Web 服务器。
3. Web 服务器调用动态消息服务，以取得动态消息。
4. 动态消息服务从缓存中取得一堆推文 ID。
5. 用户的动态消息并不只是一大堆个人动态 ID，还要包括更多用户和动态的详细信息。因此，该服务会从缓存取得完整信息。
6. 完整的动态消息会以 JSON 格式送回客户端，以进行渲染。

### 缓存架构

将缓存层分为5层

| 层次     |           |          |      |
| -------- | --------- | -------- | ---- |
| 动态消息 | 动态消息  |          |      |
| 内容     | 热门缓存  | 一般     |      |
| 社群图谱 | followers | 关注     |      |
| 动作     | 点赞      | 回复     | 其他 |
| 计数器   | 赞数量    | 回复数量 | 其他 |
