[TOC]

# Redis 性能调优

## （一）使用复杂度高的命令

### 问题排查

1. 经常使用$*O(N)*$复杂度以上的命令。如`SORT`、`SUNION`等聚合命令。
2. 使用$*O(N)*$的命令，但N特别大。
3. 如果Redis实例的`CPU`占用资源过多，则很可能是使用了复杂的命令。

### 解决方案

1. 尽量不使用*O*(*N*)以上的命令，聚合操作放到客户端。
2. 执行$*O(N)*$，使N足够小。

## （二）操作bigkey

### 问题排查

1. 查询慢日志时，若发现耗时长都是由于`SET/DEL`命令出现，可能是出现了`bigkey`。
2. 若`bigkey`特别大，则写入时分配内存的耗时长，删除时所释放内存需要的耗时也相应的变长。
3. 使用`bigkeys`命令可以扫描系统中的`bigkey`。底层是`SCAN`命令。若对线上实例Redis进行扫描造成OPS激增，可以通过`i`参数控制扫描频率。
4. 对于扫描之后的容器类型（如ziplist、skiplist、map等）的key，只能扫描出最多的key。因此扫描也不能证明系统中必定含有`bigkey`。

### 解决方案

1. 尽量避免使用`bigkey`。
2. Redis 4.0以上，可以使用`UNLINK`命令替代`DEL`命令，减少释放内存所需的耗时。Redis 6.0以上，可以开启`lazy-free`机制。

## （三）缓存雪崩——大量键集中过期

### 问题排查

1. 注意Redis 若变慢的时间很有规律，如某个整点或每间隔相同时间发生一次延迟，就有可能是缓存雪崩。
2. 当Redis使用主动过期的策略，主动过期key的定时任务，是在Redis主线程中执行的。如果此时需要过期删除的是一个`bigkey`，这个操作延时的命令并不会记录在慢日志中，因为慢日志中只记录一个命令真正操作内存数据的耗时，而Redis主动删除过期key的逻辑，是在**命令真正执行之前**执行的。

### 解决方案

1. 在代码查找`expireat/pexpireat`命令。
2. 在集中过期key上加入随机时间，将过期时间打散。
3. Redis 4.0以上，开启`lazy-free`机制，当删除过期key时，将释放内存的操作放到后台线程去执行，避免阻塞主线程。

## （四）实例内存达到上限

### 问题排查

1. 当达到`maxmemory`后，Redis 每次写入数据都先维护实例大小。即写入数据时，由于内存已经满了，会将旧数据通过淘汰策略清理。
2. 上述释放内存的淘汰策略是在执行操作命令之前，所以命令耗时更长了。

### 解决方案

1. 避免存储`bigkey`，降低释放内存的耗时。
2. 更换淘汰策略，随机算法比LRU算法更快。
3. 拆分实例，把淘汰key的压力分摊到多个实例上。
4. Redis 4.0以上，开启`lazy-free`机制，将淘汰key释放内存的操作放到后台线程来执行。

## （五）FORK 耗时严重

### 问题排查

1. 开启后台定时RDB和AOF重写功能，有可能导致Redis耗时变长。
2. 因为上述两个操作都会使主进程创建子进程，然后会调用`fork`函数。在`fork`执行过程中，主进程需要拷贝自己的内存主页给子进程，此时整个`fork`过程需要**消耗大量的CPU资源**。
3. 当主从节点第一次建立数据同步时，主节点也创建子进程生成RDB，然后发给从节点进行一次全量同步，所以该过程也会调用`fork`函数。
4. 通过在Redis上执行`INFO`命令，查看`latest_fork_usec`项，以确认是否是因为`fork`耗时导致的延迟变大。

### 解决方案

1. 控制Redis实例内存，尽量是在10G以下。实例越大，`fork`的耗时就越长。
2. 合理配置持久化策略，在`slave`节点执行RDB备份；在低峰期，可以适当地关闭RDB和AOF重写功能。
3. Redis不要部署在虚拟机上，`fork`函数在物理机上的耗时更短。
4. 适当调大`repl-backlog-size`，避免主从全量同步的概率。

## （六）开启内存大页

### 问题排查

1. Redis 在执行后台RDB和AOF 重写时，采用fork子进程的方式来处理。但主进程fork子进程后，此时主进程依旧是可以接收写请求的，而进来的写请求，会采用`Copy On Write`（写时复制）的方式操作内存数据。写时复制：谁需要发生写操作，谁就需要先拷贝，再修改。优势就是父进程的任何写操作，都不影响子进程的数据持久化。
2. 当主进程在拷贝数据时，这个阶段就涉及到新内存的申请，如果此时操作系统开启了内存大页，即便是修改了10B的数据，Redis 在申请内存时，仍然会以2MB单位向操作系统申请，申请内存的耗时变长，进而导致每个写请求的延迟增加。

### 解决方案

1. 使用`cat`命令查看Linux系统配置项`transparent_hugepage`，是否开启了内存大页机制。
2. 内存大页的优势是在一定程度上降低应用程序申请内存的次数。但是Redis 这种对于延迟和性能极其敏感的数据库来说，我们希望Redis 在每次申请内存时，耗时尽量短，所以不建议在Redis 机器上开启这个机制。

## （七）开启AOF

### 问题排查

1. [AOF的刷盘策略](https://www.notion.so/Redis-f73a7829373e4a73bc248b86c6901445)`appendfsync`有三种：`always`、`no`、`everysec`。
2. `always`每处理一次写操作，都会把这个命令写入磁盘，该操作是在主线程上执行的，会严重影响Redis 的性能。
3. `no`把写入磁盘的时间交给操作系统决定，但当Redis 宕机时，一部分数据会丢失，对于数据丢失不敏感的业务场景，使用`no`配置是可以的。
4. `everysec`的**刷盘操作是交给子线程**后台执行的，但如果因着内存数据过大，主线程的写操作和子线程的刷盘操作依然会造成IO阻塞。

### 解决方案

1. Redis 提供了一个配置项 `no-appendfsync-on-rewrite`。开启这个配置项，当子进程在AOF重写期间，可以让后台子进程不执行刷盘操作。当然，在AOF重写期间，实例发生了宕机，会丢失更多的数据。
2. 如果占用磁盘的是其他应用程序，可以定位到哪个应用程序在大量写，将该程序迁移到其他机器上执行，以免对Redis 造成影响。
3. 如果对Redis的性能和安全性都要很高的要求，可以在硬件层面进行优化，即将磁盘换为SSD，提高磁盘的IO能力。

## （八）绑定CPU

### 问题排查

1. 在部署服务时，为提高服务性能，减少应用程序在多个CPU核心之间的上下文切换带来的损耗，通常采用的方案是：进程绑定CPU的方式提高性能。
2. 若把Redis的进程只绑定了一个CPU逻辑核心上，那么当Redis在进行数据持久化时，fork出的子进程会继承父进程的CPU使用偏好。那么此时的子进程会消耗大量的CPU资源进行数据持久化，这就导致子进程会与主进程发生CPU争抢，从而影响到主进程，导致延迟。

### 解决方案

1. 将Redis绑定在多个CPU逻辑核心上，但是因为子进程、子线程还是会在多个逻辑核心上进行切换，存在性能消耗。
2. 在Redis6.0版本以上，可以将主线程（Server和IO线程）、后台线程、后台RDB线进程、AOF重写进程，绑定固定的CPU逻辑核心，这样就避免了进程在多个CPU之间来回切换导致的性能损耗。

## （九）使用SWAP

### 问题排查

1. 若发现Redis突然变得非常慢，每次操作耗时都达到了几百毫秒甚至秒级，此时就需要检查Redis是否使用到`Swap`。
2. OS 为了缓解内存不足对应用程序的影响，允许把一部分内存中的数据换到磁盘上，以达到应用程序对内存使用的缓冲，这些内存被换到磁盘上的区域，就是`Swap`。
3. 所以当使用了`Swap`，意味着Redis 再访问这些数据，需要**从磁盘上访问读取**，而这速度比内存慢几百倍。
4. 查看`Redis Swap` 的使用情况，如果只是少量的数据被换到磁盘上，影响并不是很大；但如果是几百M甚至上GB的内存换到磁盘，Redis 的性能肯定会急剧下降。

### 解决方案

1. 增加机器内存，让Redis 有足够的内存可以使用。
2. 整理内存空间，释放足够的内存给Redis 使用，然后释放`Swap`，让Redis重新使用内存。释放`Swap`通常需要重启实例，为了避免重启实例的影响，一般会进行主从切换，先释放旧主节点的`Swap`，重启旧主节点实例，待从库的数据同步完成后，再次进行主从切换。
3. 平常预防：对Redis机器的内存和`Swap`使用情况进行监控，在内存不足或使用到`Swap`时报警出来，及时处理。

## （十）碎片整理

### 问题排查

1. 通过执行`INFO`命令，查看`mem_fragmentation_ratio`内存碎片率。
2. `mem_fragmentation_ratio = used_memory_rss / userd_memory`，即**内存碎片率 = Redis存储数据的内存大小 / OS实际分配给Redis进程的大小**。
3. 当内存碎片率超过50%以上，我们就需要采取措施降低内存碎片了。

### 解决方案

1. 若使用Redis4.0以下的版本，只能通过重启实例来解决。
2. 若使用Redis4.0以上的版本，可以开启碎片的自动整理功能。
3. 由于Redis的碎片整理工作是在主线程工作的，所以开启碎片自动整理的功能也会导致性能的降低和请求耗时。所以需要结合当前Redis机器的负载情况，对碎片整理的参数进行合适的调整。

## （十一）其他问题

1. **网络带宽过载**
2. **频繁短连接**
    - 业务中应当使用长连接操作Redis，避免频繁的短连接。
    - 可以使用脚本或其他开源组件监控Redis，但要控制访问Redis的频率，避免影响到业务请求。
3. **其他程序资源争抢**
    - Redis机器最好专项专用，避免其他程序和Redis抢占资源，而导致Redis资源不足受影响。