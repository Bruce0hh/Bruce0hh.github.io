[TOC]

# Redis 对象

## 对象的类型和编码

### 对象数据结构（5个属性）

- `type`：类型。五种类型——字符串、列表、哈希、集合和有序集合。
- `encoding`：编码。
- `void *ptr`：指向底层实现数据结构的指针。
- `int refcount`：引用计数。
- `unsigned lru`：记录对象最后一次被命令程序访问的时间。

### 对象类型

| 对象名称     | 类型常量     |
| ------------ | ------------ |
| 字符串对象   | REDIS_STRING |
| 列表对象     | REDIS_LIST   |
| 哈希对象     | REDIS_HASH   |
| 集合对象     | REDIS_SET    |
| 有序集合对象 | REDIS_ZSET   |



### 对象编码

| 编码常量   | 数据结构                   |
| ---------- | -------------------------- |
| int        | long类型整数               |
| embstr     | embstr编码的简单动态字符串 |
| raw        | 简单动态字符串             |
| ht         | 字典                       |
| linkedlist | 双端链表                   |
| ziplist    | 压缩列表                   |
| inset      | 整数集合                   |
| skiplist   | 跳表和字典                 |



## 字符串

> 字符串对象的编码可以是int、raw或者embstr。
> 

### 字符串编码

- 若字符串保存的是整数值，并且可以用long类型来表示，则会将整数值保存在ptr属性里，字符串编码为int。
- 若字符串保存的是一个字符串值，且字符串值大于32字节，则使用SDS保存字符串值，字符串编码为raw。
- 若字符串保存的是一个字符串值，且字符串值小于等于32字节，字符串编码为embstr。（可以用long double类型表示的浮点数在Redis中也是作为字符串值来保存的）

### raw 和 embstr

- raw和embstr的数据结构均为：`redisObject`+`sdshdr`结构。
- embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。
- 释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。
- 因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势。

### 编码转换

- `int -> raw`：将对象从整数值变成字符串值，会导致int转raw。
- `embstr -> raw`：由于embstr字符串对象是只读的，当执行修改命令时，会导致embstr转raw。

## 列表对象

> 列表对象的编码可以是ziplist或者linkedlist。
> 

### 编码转换

- 当满足以下两种情况，对象使用`ziplist`编码：
    1. 列表对象保存的所有字符串元素的长度都小于64字节；
    2. 列表对象保存的元素数量小于512个。
- 不能满足这两个条件的列表对象需要使用`linkedlist`编码。
- 上述两个上限值（64和512）可以在配置文件中修改。

## 哈希对象

> 哈希对象的编码可以是ziplist或者hashtable。
> 

### `ziplist`编码

- 当新键值加入哈希对象时，先将保存键的`ziplist`节点推入表尾，再将保存值的节点推入`ziplist`表尾。
- 同一键值对的两个节点总是紧挨在一起，键节点在前，值节点在后。

### `hashtable`编码

- 哈希对象中的每个键值对都使用一个字典键值对来保存。
- 每个键/值都是一个字符串对象，对象保存键值对的键/值。

### 编码转换（基本同列表）

- 当哈希对象可以同时满足以下两个条件时，哈希对象使用`ziplist`编码：
    1. 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；
    2. 哈希对象保存的键值对数量小于512个。
- 不能满足这两个条件的列表对象需要使用`linkedlist`编码。
- 上述两个上限值（64和512）可以在配置文件中修改。

## 集合对象

> 集合对象的编码可以是intset或者hashtable。
> 

### 编码转换

- 当集合对象可以同时满足以下两个条件时，对象使用intset编码：
    1. 集合对象保存的所有元素都是整数值；
    2. 集合对象保存的元素数量不超过512个。
- 不能满足这两个条件的集合对象需要使用hashtable编码。
- 上述的上限值在相关配置文件中可以修改。

## 有序集合

> 有序集合的编码可以是ziplist或者skiplist。
> 

### `ziplist`

- 每个集合元素使用两个紧挨在一起的ziplist节点来保存，第一个节点保存元素的成员（member），第二个元素保存元素的分值（score）。
- ziplist的集合元素按分值从小到大进行排序。

### `skiplist`

- skiplist编码的有序集合对象使用`zset`结构作为底层实现，一个zset结构同时包含一个字典(dict)和一个跳跃表(zskiplist)。
- 每个集合元素都是一个字符串对象，而每一个元素的分值都是一个`double`类型的浮点数。
- 上述两种数据结构会通过指针来共享相同元素的成员和分值，所以同时使用跳表和字典来保存元素不会产生任何重复成员或者分值，也不会浪费额外的内存。

### zskiplist

- zset结构中的跳表按分值（score）从小到大保存了所有集合元素。
- 每个跳表节点保存了一个集合元素：object保存了元素成员，score保存了元素的分值。

### dict

- 字典的每个键值都保存了一个集合元素。
- 字典的键保存元素成员，字典的值保存了元素的分值。
- 通过字典，可以用*O*(1)复杂度查找给定成员的分值。

### `zset`结构的优点（为何同时使用dict和zskiplist）

- 单独使用字典或跳表，性能会有所降低。
- 若只使用字典，字典以无序方式保存集合元素，但使用`zrank`、`zrange`等命令时，都需要对字典保存的所有元素进行排序，完成排序至少需要*O*(*NlogN*)时间复杂度，以及额外的*O*(*N*)内存空间。
- 若只使用跳表，执行范围操作的优点保留，但根据成员查找分值的操作将*O*(1)上升至*O*(*logN*)。

### 编码转换

- 当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：
    1. 有序集合保存的元素数量小于128个；
    2. 有序集合保存的所有元素成员的长度都小于64字节。
- 上述两个上限值（128和64）可以在相关配置文件中修改。

## 类型检查 & 多态命令

- 类型检查根据`redisObject`的`type`属性来实现的。
- 对于某些命令（`del`、`expire`、`type`等命令）,是基于编码的多态——一个命令可以同时用于处理多种不同编码。
- 对于类似`llen`的命令，是基于类型的多态——一个命令可以同时用于处理多种不同类型的键。

## 内存回收

- 使用`redisObject`中的`refcount`属性对对象引用计数，当计数值为0时，对象占用的内存会被释放。

## 对象共享

- 让多个键共享同一个值对象：
    1. 将数据库键的值指针指向一个现有的值对象。
    2. 将被共享的值对象的引用计数加一。
- Redis在初始化服务器时，创建一万个字符串对象，这些对象包含了0\~9999的所有整数值，当服务器使用值为0\~9999的字符串对象时，服务器就会使用这些共享对象，而不是创建新对象。
- 不单单只有字符串键可以使用这些共享对象，在数据结构中嵌套了字符串对象的对象，都可以使用这些共享对象。
- 受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。