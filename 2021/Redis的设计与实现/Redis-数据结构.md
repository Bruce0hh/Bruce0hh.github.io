[TOC]

# Redis 数据结构

## SDS 简单动态字符串

### SDS 结构

- `len` 记录SDS的长度
- `free` 未用以存储的字符空间
- `char[] buf` 用以存储的字节数组

### SDS 优点

1. 查询字符串长度，时间复杂度为 $O(N)$；而查询SDS的长度，时间复杂度为 $*O(1)*$。

2. 通过`free` 字段实现空间预分配和惰性释放，降低修改字符串的复杂度，并且杜绝了缓冲区溢出的问题。

3. SDS 保证了二进制安全。

   - 二进制安全：在处理字符串时候不会以零值字节(`'\\0'`)为字符串结尾标志。SDS由于可以通过`len` 属性保存 SDS 的长度，所以可以存储二进制数据。

   > C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。

## 链表

### 链表结构

- listNode 结构
  - `prev` 前置指针
  - `next` 后置指针
  - `value` 节点值
- list 结构
  - `head` 头节点
  - `tail` 尾节点
  - `len` 链表长度，即链表包含的 `listNode` 的个数
  - `dup` 节点复制函数
  - `free` 节点释放函数
  - `int match` 节点值比较

### 链表特点

1. 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是 $O(1)$。
2. 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。
3. 多态：通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。

## 字典

### 字典结构

- 哈希表节点`dictEntry`结构
  - `key` ：键
  - `v` ：值，可以是**指针**，或是 `uint64_t` 整数，或是 `int64_t` 整数
  - `next` ：指向下个哈希表的指针
- 哈希表`dictht`结构
  - `dictEntry **table`：哈希表数组
  - `size` ：哈希表大小
  - `sizemask`：哈希表大小掩码，用于计算索引值，总是等于 `size - 1`
  - `used`：哈希表已有节点的数量
- 字典函数`dictType`结构
  - `hashFunction` ：计算哈希值
  - `keyDup` ：复制键
  - `valDup` ：复制值
  - `keyCompare` ：对比键
  - `keyDestructor` ：销毁键
  - `valDestructor` ：销毁值
- 字典`dict`结构
  - `dictType *type`： 类型特定函数
  - `privdata` ：私有数据
  - `dictht ht[2]` ：哈希表，一个平时使用，一个仅在 rehash 时使用
  - `rehashidx` ：`rehash` 索引，当 rehash 不在进行时，值为 -1

### 内部算法

- 解决哈希冲突
  - 拉链法：将哈希冲突的键值对用链表存储，同 Java 中 `HashMap` 的操作
- 扩容和收缩哈希表
  - 扩容：`ht[1]` 的大小**大于等于** `ht[0].used * 2` 的 $2^n$
  - 收缩：`ht[1]` 的大小**大于等于**`ht[0].used` 的 $2^n$
  - ex：`ht[0].used = 5`，扩容应为**大于等于**10的2次方幂，`ht[1]` 应为16
- 渐进式 rehash
  1. 维护 `ht[0]` 和 `ht[1]`
  2. 在 `ht[0]` 上做 CRUD 的操作时，把 `rehashidx` 上的整个链表迁移至 `ht[1]`
  3. 最后 `ht[0]` 上的数据全部迁移到 `ht[1]` ，完成后 `rehashidx = 1`

### 字典特点

1. 字典是Redis中数据库和哈希键的底层实现之一。
2. 字典的底层是两个哈希表，一个平时使用，一个仅在rehash时使用。
3. 字典使用MurmurHash2算法来计算键的哈希值。
4. 哈希表使用链地址法来解决哈希冲突，将冲突的键用链表存储。
5. 在扩容或收缩哈希表的时候，使用渐进式rehash的方式，而非一次性rehash到新哈希表中。

## 跳表

### 跳表结构

- 跳跃表节点（zskipNode）

  - #### `level`层：记录当前跳表内，层数最大的那个节点的层数。

    - `zskiplistNode *forward`：前进指针。一个节点包含多个前进指针，每层都有一个。
    - `span`：跨度。记录两个节点之间的距离；**指向 null 的所有前进指针跨度都为0**。

  - `zskiplistNode *backward`：后退指针。一个节点只有一个后退指针。

  - `double score`：分值。跳表中**所有的节点按照分值从小到大排序**。

  - `obj`：成员对象。obj 是一个指针，指向一个字符串对象，对象中保存一个 SDS 值。

- 跳跃表 （zskiplist）

  - `zskiplistNode *header, *tail`：表头节点、表尾节点。通过这两个指针，程序定位表头表尾的复杂度为 $O(1)$。
  - `length`：表中节点的数量。通过 length 属性使程序在$O(1)$内返回跳跃表的长度。
  - `level`：表中层数最大的节点的层数。用于在$O(1)$内获取跳表中最大的节点层数，**表头层高不计算入内**。

### 跳表特点

1. 跳跃表是有序集合的底层实现之一。
2. 跳表由 `zskiplist` 和 `zskiplistNode` 两个结构组成。前者保存跳表信息，后者表示跳表节点。
3. 在同一个跳表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一。
4. 跳表中的节点按分值大小排序，若分值相同，按成员对象大小排序。
5. 跳表的层高是1~32的随机数。
6. 跳表生成节点：根据幂次定律随机生成层高。
7. 跳表遍历：从左到右，从高到低。

## 整数集合（INTSET）

### 整数集合结构

- `uint32_t encoding`：编码方式。
- `uint32_t length`：集合包含的元素数量。也就是contents数组的长度。
- `int8_t contents[]`：保存元素的数组。实际上contents的数据类型取决于encoding属性。

### 升级

> 每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集 合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。

1. **扩展**：根据新元素的类型，扩展数组的大小，为新元素分配空间。
2. **转换**：将底层数组所有的元素都转换成新元素相同的类型。
3. **添加**：将新元素放置正确的位置，保持数组有序性质不变。

### 升级之后新元素的摆放位置

> 引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素

- 由于整数有正负值，所以引发升级的新元素一定是，**大于或小于**所有现有元素。
- 在新元素小于所有现有元素的情况下，新元素会被放置在底层数组的最开头（索引0）。
- 在新元素大于所有现有元素的情况下，新元素会被放置在底层数组的最末尾（索引length-1）。

### 升级的优势

### 提升灵活性

- 为了避免类型错误，通常在C语言中不会将两种不同类型的值放在同一个数据结构里面。
- 整数集合通过升级的方式，将不同类型的值放到同一个数据结构中，不用担心类型错误。

### 节约内存

> 要让一个数组可以同时保存`int16_t`、`int32_t`、`int64_t`三种类型的值，最简单的做法就是直接使用int64_t类型的数组作为整数集合的底层实现。而整数集合现在的做法既可以让集合能同时保存三种不同类型的值，又可以确保升级操作只会在有需要的时候进行，这可以尽量节省内存。

### 整数集合特点

1. 整数集合是集合键的底层实现之一。
2. 整数集合底层为数组，以有序、无重复方式保存集合元素。
3. 整数集合只支持升级操作、不支持降级。

## 压缩列表

### 压缩列表结构

> 压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（`sequential`）数据结构。一个压缩列表可以包含任意多个节点（`entry`），每个节点可以保存一个字节数组或者一个整数值。

- `zlbytes`：记录整个压缩列表占用的内存字节数。
- `zltail`：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节。
- `zllen`：记录了压缩列表包含的节点数量。
- `entryX`：压缩列表包含的各个节点。
- `zlend`：特殊值`0xFF`，用于标记压缩列表的末端。

### 压缩列表节点的构成

- 每个压缩列表节点可以保存一个字节数组或者一个整数组。

### previous_entry_length

1. 记录了压缩列表中前一个节点的长度。
2. 可以通过指针运算，根据当前节点的其实地址来计算出前一个节点的起始地址。
3. 从表尾向表头遍历操作就是使用这原理实现的，通过尾节点的起始地址的指针，一直向前一个指针回溯。

### encoding

1. 记录了节点的`content`属性所保存数据的类型及长度。
2. “00 01 10”开头的是字节数组编码；数组长度由编码除去最高两位之后的其他位记录。
3. “11”开头的是整数编码；整数值的类型和长度由编码除去最高两位之后的其他位记录。

### content

> 节点的`content`属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的`encoding`属性决定。

### 连锁更新

- 当前一节点的长度<254字节，`previous_entry_length`用**1字节**保存长度值；
- 当前一节点的长度≥254字节，`previous_entry_length`用**5字节**保存长度值。
- 添加新节点有可能会导致后一个节点的`previous_entry_length`增加长度，导致空间重分配，然后会致使不断地对节点的连锁更新。删除节点同样可能会导致连锁更新。

### 性能问题

- 连锁更新在最坏情况需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为$O(N)$，所以连锁更新的最坏复杂度为$O(N^2)$。

压缩列表恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发。

- 只要被更新的节点数量不多，就不会性能造成任何影响。

### 压缩列表特点

1. 压缩列表是列表键和哈希键的底层实现之一。
2. 压缩列表是一种节约内存而开发的顺序型数据结构。
3. 压缩列表可以包含多个节点，节点可以保存一个字节数组或整数值。
4. 添加或删除节点都可能会引发连锁更新操作，但是几率不高且性能影响不大。