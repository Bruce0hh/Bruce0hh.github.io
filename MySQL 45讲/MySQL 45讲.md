# 基础架构

```sql
mysql> select * from T where ID=10；
```

- MySQL 可以分为 Server 层和存储引擎层两部分。
- Server 层包括连接器、查询缓存、分析器、优化器、执行器等。
- 存储引擎层负责数据的存储和提取。

## 连接器

- 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。
- 客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 `wait_timeout` 控制的，默认值是 8 小时。
- 建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。
- 长连接累积过多会导致内存占用太大，可能会导致OOM。有如下解决方案：
  1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
  2.  MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 `mysql_reset_connection `来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

## 查询缓存

- 之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。
- 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。
- 对于更新压力大的数据库来说，查询缓存的命中率会非常低。
- 你可以将参数 `query_cache_type` 设置成 `DEMAND`，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 `SQL_CACHE` 显式指定。
- MySQL 8.0 版本直接将查询缓存的整块功能删掉了。

## 分析器

- 分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。
- 根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

## 优化器

- 优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。
- 优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。

## 执行器

- 开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。

# 日志系统

```sql
mysql> update T set c=c+1 where ID=2;
```



## `redo log`

- MySQL 里经常说到的 WAL 技术，WAL 的全称是 `Write-Ahead Logging`，它的关键点就是先写日志，再写磁盘。
- 当有一条记录需要更新的时候，`InnoDB` 引擎就会先把记录写到 `redo log`（粉板）里面，并更新内存，这个时候更新就算完成了。同时，`InnoDB` 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。
- `InnoDB` 的 `redo log` 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写。
- `write pos` 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。`checkpoint` 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。
- 如果 `write pos` 追上 `checkpoint`，表示 `redo log`（粉板）满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 `checkpoint` 推进一下。
- 有了 `redo log`，`InnoDB` 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**。

## `binlog`

- `redo log` 是 `InnoDB` 引擎特有的日志，而 Server 层也有自己的日志，称为 `binlog`（归档日志）。
- 两种日志的不同
  1. `redo log` 是 `InnoDB` 引擎特有的；`binlog` 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
  2. `redo log` 是物理日志，记录的是**在某个数据页上做了什么修改**；`binlog` 是逻辑日志，记录的是这个语句的原始逻辑，**比如给ID=2这一行的c字段加1** 。
  3. `redo log` 是循环写的，空间固定会用完；`binlog` 是可以追加写入的。**追加写**是指 `binlog` 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。
- 步骤
  1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
  2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
  3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 `redo log` 里面，此时 `redo log` 处于 `prepare` 状态。然后告知执行器执行完成了，随时可以提交事务。
  4. 执行器生成这个操作的 `binlog`，并把 `binlog` 写入磁盘。
  5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 `redo log` 改成提交（`commit`）状态，更新完成。

### 两阶段提交

- 将 `redo log` 的写入拆成了两个步骤：`prepare` 和 `commit`，这就是"两阶段提交"。
- **如果不使用两阶段提交**：
  1. **先写 `redo log` 后写 `binlog`**。
     1. 假设在 `redo log` 写完，`binlog` 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，`redo log` 写完之后，系统即使崩溃，仍然能够把数据恢复回来。
     2. 但是由于 `binlog` 没写完就 `crash` 了，这时候 `binlog` 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 `binlog` 里面就没有这条语句。
  2. **先写 `binlog` 后写 `redo log`**。
     1. 如果在 `binlog` 写完之后 `crash`，由于 `redo log` 还没写，崩溃恢复以后这个事务无效。
     2. 但是 `binlog` 里面已经记录了**把 c 从 0 改成 1**这个日志。所以，在之后用 `binlog` 来恢复的时候就多了一个事务出来。
- 如果不使用“**两阶段提交**，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。
- 不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 `binlog` 来实现的，这个**不一致**就会导致你的线上出现主从数据库不一致的情况。
- 简单说，`redo log` 和 `binlog` 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。

# 事务隔离

## 隔离性和隔离级别

- **读未提交**：一个事务还没提交时，它做的变更就能被别的事务看到。
- **读提交**：一个事务提交之后，它做的变更才会被其他事务看到。
- **可重复读**：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- **串行化**：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

在隔离级别实现上，数据库里面会创建一个**视图**，访问的时候以视图的逻辑结果为准。

- **读未提交**：直接返回记录上的最新值，没有视图概念。
- **读提交**：这个视图是在每一个SQL语句开始执行的时候创建的。
- **可重复读**：这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。
- **串行化**：直接用加锁的方式来避免并行访问。

## 事务隔离的实现

- 在MySQL中，实际上**每条记录在更新的时候都会同时记录一条回滚操作**。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。
- 在查询这条记录的时候，不同时刻启动的事务会有不同的 `read-view`。
- 同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（`MVCC`）。
- 系统会判断，当没有事务再需要用到这些回滚日志（`undo log`）时，回滚日志会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 `read-view` 的时候。
- 尽量不要使用长事务
  - 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。
  - 在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 `ibdata` 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。
  - 除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。

### 如何避免长事务

#### 开发端

1. 确认是否使用了`set autocommit=0`。这个确认工作可以在测试环境中开展，把MySQL的`general_log`开起来，然后随便跑一个业务逻辑，通过`general_log`的日志来确认。目标就是将其改为1。
2. 确认是否使用有不必要的只读事务。如果业务中没有这个事务需要，不要将`select`语句放到事务中，这种只读事务可以去掉。
3. 业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。

#### 数据库端

1. 监控 `information_schema.Innodb_trx` 表，设置长事务阈值，超过就报警或者 kill；
2. `Percona` 的 `pt-kill` 这个工具不错，推荐使用；
3. 在业务功能测试阶段要求输出所有的 `general_log`，分析日志行为提前发现问题；
4. 如果使用的是 MySQL 5.6 或者更新版本，把 `innodb_undo_tablespaces` 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。  

