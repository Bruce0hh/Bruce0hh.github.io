# 备库并行复制

<img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/1a85a3bac30a32438bfd8862e5a34eef.png" alt="img" style="zoom: 50%;" />

- 第一个黑色箭头代表了客户端写入主库，另一个箭头代表的是备库上`sql_thread`执行中转日志。如果用箭头的粗细来代表并行度的话，第一个要远粗于第二个箭头。
- 主库上，影响并发度的原因就是各种锁。而日志在备库上的执行，就是备库上`sql_thread`更新数据的逻辑。如果用单线程的话，就会导致备库应用日志不够快，造成主备延迟。
- MySQL 5.6之前，MySQL只支持单线程复制，由此在主库并发高、TPS高的时候就会出现严重MySQL多线程复制的演进过程。

## 多线程复制机制

<img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/bcf75aa3b0f496699fd7885426bc6245.png" alt="img" style="zoom:50%;" />

- `coordinator`就是原来的`sql_thread`，不过现在它不再直接更新数据了，只负责读取中转日志和分发事务。真正更新日志的，变成了worker线程。而worker线程的个数，就是由参数`slave_parallel_workers`决定的。
- **事务能否按照轮询的方式分发给各个worker？**如，第一个事务发给worker_1，第二个事务发给worker_2等。不行，因为事务被分发后，不同的worker独立执行，由于CPU的调度策略，很可能第二个事务最终比第一个事务先执行。如果这两个事务更新的是同一行，主库和备库的执行顺序相反，会导致主备不一致的问题。
- **同一个事务的多个更新语句，能不能分给不同的worker来执行呢？**不行，当一个事务更新了表t1和表t2中的各一行，如果这两条更新语句被分到不同的worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到了这个事务“更新了一半的结果”，破坏了事务逻辑的隔离性。

### coordinator的基本条件

1. 不能造成更新覆盖。这就要求更新同一行的两个事务，必须分发到同一个worker中。
2. 同一个事务不能被拆开，必须放到同一个worker中。

## MySQL 的并行复制策略

- **对于按表分发的策略**：如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。
- **对于按行分发的策略**：对于行分发策略，对于一个worker线程的唯一值来说，主键id是不够的，还需要考虑唯一索引，保证事务更新行的语句在worker的执行顺序是一致的。同时，按行分发的策略会**更消耗内存**，因为需要记录更多的行hash值；**更消耗CPU**，因为需要解析binlog，计算hash，对于大事务来说，成本还是很高的。
- **按表和按行策略的约束条件**：
  1. 要从binlog里解析出表名、主键值和唯一索引的值。也就是说主库的binlog格式必须是row。
  2. 表必须有主键。
  3. 不能有外键。表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准确了。

## MySQL 5.6版本的并行复制策略

MySQL5.6版本，支持了并行复制，支持的粒度是按库并行。用于决定分发策略的hash表里，key就是数据库名。

### 优势：

1. 构造hash值的时候很快，只需要库名；而且一个实例上的DB数也不会很多，不会出现需要构造100万个项这种情况。
2. 不要求binlog格式为row。因为statement格式的binlog也可以很容易拿到库名。

### 劣势：

对于单DB的系统，这个策略没有效果；或者如果不同的DB热点不同，比如一个业务DB，一个系统配置DB，那也起不到并行的效果。

## MariaDB 的并行复制策略

1. 在一组里面一起提交的事务，有一个相同的 commit_id，下一组就是 commit_id+1；
2. commit_id 直接写到 binlog 里面；
3. 传到备库应用的时候，相同 commit_id 的事务分发到多个 worker 执行；
4. 这一组全部执行完成后，coordinator 再去取下一批。

**MariaDB 这个策略的核心，是“所有处于 commit”状态的事务可以并行。事务处于 commit 状态，表示已经通过了锁冲突的检验了。**

**注意：**这个方案很容易被大事务拖后腿。假设 trx2 是一个超大事务，那么在备库应用的时候，trx1 和 trx3 执行完成后，就只能等 trx2 完全执行完成，下一组才能开始执行。这段时间，只有一个 worker 线程在工作，是对资源的浪费。

## MySQL 5.7版本的并行复制策略

类似以上的MariaDB，MySQL5.7使用参数`slave-parallel-type`控制并行复制策略：

1. 配置为DATABASE，表示使用MySQL5.6版本的按库并行策略；
2. 配置为LOGICAL_CLOCK，表示的就是类似MariaDB的策略。

MySQL 5.7 并行复制策略的思想是：

1. 同时处于**prepare**状态的事务，在备库执行时是可以并行的；
2. 处于**prepare**状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的。

通过控制`binlog_group_commit_sync_delay`或`binlog_group_commit_sync_no_delay_count`参数，故意拉长binlog从write到fsync的时间，以此减少binlog的写盘次数，制造更多的“同时处于prepare阶段的事务”，这样就增加了备库复制的并行度。
